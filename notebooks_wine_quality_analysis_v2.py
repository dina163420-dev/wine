# -*- coding: utf-8 -*-
"""notebooks_wine_quality_analysis_v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/compozallo/wine/blob/main/notebooks_wine_quality_analysis_v2.ipynb

Анализ качества вина и прогнозная модель
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier
from sklearn.metrics import mean_squared_error, r2_score, classification_report, confusion_matrix, roc_auc_score, RocCurveDisplay
from sklearn.preprocessing import StandardScaler
import scipy.stats as stats
import warnings
warnings.filterwarnings('ignore')
sns.set(style='whitegrid')

"""Импортированы все необходимые библиотеки для анализа данных"""

red_url = 'https://raw.githubusercontent.com/compozallo/wine/main/winequality-red.csv'
white_url = 'https://raw.githubusercontent.com/compozallo/wine/main/winequality-white.csv'


df_red = pd.read_csv(red_url, sep=';')
df_white = pd.read_csv(white_url, sep=';')


df_red['wine_type'] = 'red'
df_white['wine_type'] = 'white'


df = pd.concat([df_red, df_white], ignore_index=True)


print('Размер объединённого датасета:', df.shape)
df.head()

def quality_label(q):
    if q <= 4:
        return 'bad'
    elif q <= 6:
        return 'medium'
    else:
        return 'good'

df['quality_label'] = df['quality'].apply(quality_label)


display(df['quality_label'].value_counts().to_frame('count'))

"""Загружены два датасета (красные и белые вина),далее каждому датасету добавлен столбец wine_type для маркировки типа вина (датасеты объединены в один (6497 образцов, 13 признаков) ). Структура данных включает 12 физико-химических параметров + целевая переменная "качество" + метка типа вина."""

numeric_cols = df.select_dtypes(include='number').columns

grouped = df.groupby('quality_label')[numeric_cols]
summary = grouped.agg(['count','mean','median','std'])


df_bad = df[df['quality_label']=='bad']
df_medium = df[df['quality_label']=='medium']
df_good = df[df['quality_label']=='good']


print('--- Плохое качество (bad) — краткая сводка')
display(df_bad.describe().T)

print('--- Среднее качество (medium) — краткая сводка')
display(df_medium.describe().T)

print('--- Хорошее качество (good) — краткая сводка')
display(df_good.describe().T)

"""Разница между good и bad составляет 1.23% - статистически значимая(p < 0,05)
По другим параметрам мы узнали,что летучая кислотность уменьшается с ростом качества (с 0.465 до 0.289);cульфаты увеличиваются с ростом качества (с 0.506 до 0.612);плотность немного ниже у хороших вин.
Далее проверим гипотезу "Вина с более высоким содержанием алкоголя имеют более высокую оценку качества" и сравним распределения процента алкоголя между тремя группами.
"""

alc_bad = df_bad['alcohol'].dropna()
alc_med = df_medium['alcohol'].dropna()
alc_good = df_good['alcohol'].dropna()

print('Среднее alcohol по группам:')
print('bad:', alc_bad.mean().round(3), 'medium:', alc_med.mean().round(3), 'good:', alc_good.mean().round(3))


f_stat, p_val = stats.f_oneway(alc_bad, alc_med, alc_good)
print('ANOVA F-statistic =', round(f_stat,4), ', p-value =', p_val)


pairs = [(alc_bad, alc_med, 'bad_vs_med'), (alc_bad, alc_good, 'bad_vs_good'), (alc_med, alc_good, 'med_vs_good')]
alpha = 0.05
results = []
for a,b,name in pairs:
    t, p = stats.ttest_ind(a,b, equal_var=False)
    results.append((name, t, p))


print('Парные t-тесты (Welch) с поправкой Бонферрони:')
for name,t,p in results:
    p_adj = min(p*3,1.0)
    print(name, 't=', round(t,3), 'p=', round(p,6), 'p_adj=', round(p_adj,6))


if p_val < 0.05:
    print('Общий ANOVA показал статистически значимые различия в alcohol между группами (p < 0.05).')
else:
    print('ANOVA не показал статистически значимых различий (p >= 0.05).')

"""Гипотеза об алкоголе подтверждается на уровне групп

Bad: 10.18% алкоголя  Medium: 10.27% алкоголя  Good: 11.41% алкоголя
Существует явный градиент — чем лучше вино, тем выше содержание алкоголя.
Дисперсионный анализ показал, что существуют статистически значимые различия в среднем содержании алкоголя между двумя группами качества (p < 0.05).

Вывод гипотеза подтверждена

Вина с алкоголем < 10.5% редко получают высокие оценки (больше 7).

Увеличение алкоголя на 1% может повысить шансы на попадание в категорию "хороших" вин.

"""

plt.figure(figsize=(10,4))
plt.subplot(1,2,1)
sns.boxplot(x='quality_label', y='alcohol', data=df, order=['bad','medium','good'])
plt.title('Alcohol по группам качества')

plt.subplot(1,2,2)
sns.scatterplot(x='alcohol', y='quality', hue='quality_label', data=df, alpha=0.4, palette=['red','orange','green'])
plt.title('Quality vs Alcohol (точки)')
plt.tight_layout()
plt.show()

"""Переходим к моделированию. Будем строить:
- регрессию (предсказание числового quality)
- классификатор для метки good (quality >= 7) — бинарная классификация
Обе модели сделаем на RandomForest с простой предобработкой.

"""

features = ['fixed acidity','volatile acidity','citric acid','residual sugar','chlorides',
            'free sulfur dioxide','total sulfur dioxide','density','pH','sulphates','alcohol']
X = df[features].copy()
y_reg = df['quality'].copy()

y_clf = (df['quality'] >= 7).astype(int)


scaler = StandardScaler()
X_scaled = pd.DataFrame(scaler.fit_transform(X), columns=X.columns)

X_train, X_test, y_reg_train, y_reg_test = train_test_split(X_scaled, y_reg, test_size=0.2, random_state=42)
_, _, y_clf_train, y_clf_test = train_test_split(X_scaled, y_clf, test_size=0.2, random_state=42)

print('Train size:', X_train.shape, 'Test size:', X_test.shape)

"""Порог качества вина 4 и меньше - плохое, 5-6 - среднее, 7 и более - хорошее.
У хороших вин самый широкий разброс (от 9% до 14%), у плохих вин самый узкий разброс.  Наличие вин с высоким алкоголем ( больше 12%) но низким качеством показывает, что алкоголь - не единственный фактор качества. Ящики групп "плохо" и "среднее" значительно перекрываются, а вот ящики группы "хорошо" смещен вправо и почти не перекрывается с плохим вином.  Зеленая зона: alcohol > 11%, quality ≥ 7 ; Красная зона alcohol < 10.5%, quality ≤ 6; Серая зона перехода
 10.5% < alcohol < 11% - смесь всех категорий. Оптимальная зона для высоких оценок 11-13% алкоголя. Также графики показали нам положительную корреляцию алкоголя и качества. Да,гипотеза действительно подтверждается,но не является гарантией качества вина.
"""

from sklearn.metrics import mean_squared_error, r2_score
import numpy as np

rf_reg = RandomForestRegressor(n_estimators=200, random_state=42, n_jobs=-1)
rf_reg.fit(X_train, y_reg_train)
y_pred_reg = rf_reg.predict(X_test)

mse = mean_squared_error(y_reg_test, y_pred_reg)
rmse = np.sqrt(mse)

r2 = r2_score(y_reg_test, y_pred_reg)

print('Регрессия RandomForest — RMSE =', round(rmse,3), ', R2 =', round(r2,3))


plt.figure(figsize=(6,5))
sns.scatterplot(x=y_reg_test, y=y_pred_reg, alpha=0.4)
plt.plot([y_reg_test.min(), y_reg_test.max()], [y_reg_test.min(), y_reg_test.max()], 'r--')
plt.xlabel('Actual quality')
plt.ylabel('Predicted quality')
plt.title('Regression: Actual vs Predicted')
plt.show()

"""Модель регрессии имеет RMSE 0.609 и R² 0.498. Это значит, что в среднем предсказания отклоняются от фактических значений на 0.61 балла (по шкале от 3 до 9). График фактического vs предсказанного указывает на общую положительную корреляцию, предсказания наиболее точны для средних значений качества (5-6),   
модель хуже предсказывает экстремальные значения (3-4 и 8-9), стремясь притягивать их к среднему.
"""

rf_clf = RandomForestClassifier(n_estimators=200, random_state=42, n_jobs=-1)
rf_clf.fit(X_train, y_clf_train)
y_pred_clf = rf_clf.predict(X_test)
y_pred_proba = rf_clf.predict_proba(X_test)[:,1]

print('Classification report (good vs not-good):')
print(classification_report(y_clf_test, y_pred_clf))

cm = confusion_matrix(y_clf_test, y_pred_clf)
plt.figure(figsize=(5,4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion matrix')
plt.show()

try:
    auc = roc_auc_score(y_clf_test, y_pred_proba)
    print('ROC AUC =', round(auc,3))
    RocCurveDisplay.from_estimator(rf_clf, X_test, y_clf_test)
    plt.show()
except Exception as e:
    print('ROC AUC error:', e)

"""Результаты RandomForestClassifier: высокая точность (89%) и разделяющая способность (AUC = 0.925), что указывает на возможность прогнозирования качества вина по химическим параметрам. Класс 0 ("плохие" вина) - 1048 образцов Класс 1 ("хорошие" вина) - 252 образцов. Модель отлично разделяет два класса по вероятностям."""

X_all_scaled = X_scaled.copy()
X_train_idx, X_test_idx = train_test_split(df.index, test_size=0.2, random_state=42)

df_test = df.loc[X_test_idx].copy()

df_test['pred_quality_reg'] = y_pred_reg
df_test['pred_good_proba'] = y_pred_proba
df_test['pred_good_label'] = y_pred_clf


table_bad = df_test[df_test['quality_label']=='bad'][['quality','pred_quality_reg','pred_good_proba','alcohol']].describe().T
table_med = df_test[df_test['quality_label']=='medium'][['quality','pred_quality_reg','pred_good_proba','alcohol']].describe().T
table_good = df_test[df_test['quality_label']=='good'][['quality','pred_quality_reg','pred_good_proba','alcohol']].describe().T

print('--- Таблица: плохое (test)')
display(table_bad)
print('--- Таблица: среднее (test)')
display(table_med)
print('--- Таблица: хорошее (test)')
display(table_good)

"""Плохие вина (качество меньше 4). Модель склонна завышать оценку качества (5.24 вместо 3.88). Вероятность отнесения к хорошим винам низкая, как и содержание алкоголя (10.26%).

Средние вина (качество 5-6). Прогнозы очень точны. Вероятность быть хорошим вином низкая. Содержание алкоголя немного выше, чем у плохих вин (10.29%).

Хорошие вина (качество больше 7). Модель немного занижает оценку (6.56 вместо 7.15), но правильно определяет высокую вероятность отношения к хорошим винам (55.9%). Содержание алкоголя самое высокое (11.50%). Вероятность быть хорошим вином связана с содержанием алкоголя.

Можно скзаать о том,что регрессионная модель хорошо предсказывает средние значения качества, но менее точна для крайних значений. Классификация имеет высокий показатель ROC AUC (0.925), но полноста нашей модели для хороших вин составляет 59%.

"""